---
title: Multi-sample analyses
vignette: >
  % \VignetteIndexEntry{Multi-sample analysis}
  %\VignetteEncoding{UTF-8}
  % \VignetteEngine{knitr::rmarkdown}
output:
  html_document:
    mathjax: null   
editor_options: 
  chunk_output_type: console
---

# Setup and data exploration

As said, we will use the the data from the Tal1 chimera experiment:

- Sample 5: E8.5 injected cells (tomato positive), pool 3
- Sample 6: E8.5 host cells (tomato negative), pool 3
- Sample 7: E8.5 injected cells (tomato positive), pool 4
- Sample 8: E8.5 host cells (tomato negative), pool 4
- Sample 9: E8.5 injected cells (tomato positive), pool 5
- Sample 10: E8.5 host cells (tomato negative), pool 5

Note that this is a paired design in which for each biological replicate (pool 3, 4, and 5), we have both host and injected cells.

We start by loading the data and doing a quick exploratory analysis, essentially applying the normalization and visualization techniques that we have seen in the previous lectures to all samples.

```{r setup, message = FALSE}
library(MouseGastrulationData)
sce <- WTChimeraData(samples=5:10, type = "processed")
sce
colData(sce)
```

We now normalize the data and visualize them in a tSNE plot.

```{r}
library(scater)
library(ggplot2)
library(scran)

# remove doublets
drop <- sce$celltype.mapped %in% c("stripped", "Doublet")
sce <- sce[,!drop]

# normalization
sce <- logNormCounts(sce)

# identify highly variable genes
dec <- modelGeneVar(sce, block=sce$sample)
chosen.hvgs <- dec$bio > 0

# dimensionality reduction
sce <- runPCA(sce, subset_row = chosen.hvgs, ntop = 1000)
sce <- runTSNE(sce, dimred = "PCA")

sce$sample <- as.factor(sce$sample)
plotTSNE(sce, colour_by = "sample")
plotTSNE(sce, colour_by = "celltype.mapped") +
    scale_color_discrete() +
    theme(legend.position = "bottom")
```

There are evident sample effects. Depending on the analysis that you want to do you may want to remove or retain the sample effect. For instance, if the goal is to identify cell types with a clustering method, one may want to remove the sample effects with "batch effect" correction methods.

For now, let's assume that we want to remove this effect.

# Correcting batch effects

We correct the effect of samples by aid of the `correctExperiment` function
in the `batchelor` package and using the `sample` `colData` column as batch.


```{r}

## This needs work
library(batchelor)
set.seed(10102)
merged <- correctExperiments(sce, 
    batch=sce$sample, 
    subset.row=chosen.hvgs,
    PARAM=FastMnnParam(
        merge.order=list(
            list(1,3,5), # WT (3 replicates)
            list(2,4,6)  # td-Tomato (3 replicates)
        )
    )
)

merged <- runTSNE(merged, dimred="corrected")
plotTSNE(merged, colour_by="batch")

# do we want to include the diagnostics about the batch correction?
```

Once we removed the sample batch effect, we can proceed with the Differential 
Expression Analysis.


# Differential Expression

Section 4 of OSCA multisample.

In order to perform a Differential Expression Analysis, we need to identify 
group of cells across samples/conditions (depending on the experimental 
design and the final aim of the experiment). 

As previously saw, we have two ways of grouping cells, cell clustering and cell
labeling.
In our case we will focus on this secon aspect to group cells accordingly to the 
already annotated cell types to proceed with the computation of the 
pseudo-bulk samples.

## Pseudo-bulk samples

To compute differences between different group of cells, a possible way is to 
compute pseudo-bulk samples, where we mediate the gene signal of all the cells
for each specific cell type.
In this manner, we are then able to detect differences between the same cell type 
across two different condition, but also across different cell types in the same condition, etcetera.

To compute pseudo-bulk samples, we use `aggregateAcrossCells` function in the 
`scuttle` package, which takes as input not only the single cell experiment, 
but also the id to use for the identification of the group of cells.
In our case, we use as id not just the cell type, but also the sample, because
we want be able to discern between replicates and conditions during further steps.

```{r}
# Using 'label' and 'sample' as our two factors; each column of the output
# corresponds to one unique combination of these two factors.
library(scuttle)
summed <- aggregateAcrossCells(merged, 
    id=colData(merged)[,c("celltype.mapped", "sample")])
summed

```

## Differential Expression Analysis

The main advantage of using pseudo-bulk samples is the possibility to use 
well-tested methods for differential analysis like `edgeR` and `DESeq2`, we will
focus on the first one for this analysis.

Before to begin our analysis, let's say that we are mostly interested in a specific
cell type, the "Mesenchymal stem cells" and look into differences across different
conditions.

<!-- To proceed with our analysis, we need to create an edgeR object for our data, so -->
<!-- we first subset our dataset for the specific cell type and then we create the object. -->

```{r}
label <- "Mesenchyme"
current <- summed[,label==summed$celltype.mapped]

# Creating up a DGEList object for use in edgeR:
library(edgeR)
y <- DGEList(counts(current), samples=colData(current))
y
```

Discard lowly "sequenced" samples

```{r}
discarded <- current$ncells < 10
y <- y[,!discarded]
summary(discarded)
```


Discard lowly expressed genes

```{r}
keep <- filterByExpr(y, group=current$tomato)
y <- y[keep,]
summary(keep)
```

Normalization factors by TMM

```{r}
y <- calcNormFactors(y)
y$samples
```

MD plot

```{r}
par(mfrow=c(2,3))
for (i in seq_len(ncol(y))) {
    plotMD(y, column=i)
}
```

MDS plot
    
```{r}
plotMDS(cpm(y, log=TRUE), 
    col=ifelse(y$samples$tomato, "red", "blue"))
```


```{r}
design <- model.matrix(~factor(pool) + factor(tomato), y$samples)
design
```

```{r}
y <- estimateDisp(y, design)
summary(y$trended.dispersion)
plotBCV(y)
```

```{r}
fit <- glmQLFit(y, design, robust=TRUE)
summary(fit$var.prior)
summary(fit$df.prior)
plotQLDisp(fit)
```

```{r}
res <- glmQLFTest(fit, coef=ncol(design))
summary(decideTests(res))
topTags(res)
```


All the previous steps can be easily performed with the followin function

```{r}
library(scran)
#?pseudoBulkDGE(y)
```



# Differential Abundance

Section 6.3 of OSCA multisample.

<!-- from section 6.2-->

```{r}
library(edgeR)
abundances <- table(merged$celltype.mapped, merged$sample) 
abundances <- unclass(abundances) 
# Attaching some column metadata.
extra.info <- colData(merged)[match(colnames(abundances), merged$sample),]
y.ab <- DGEList(abundances, samples=extra.info)
keep <- filterByExpr(y.ab, group=y.ab$samples$tomato)
y.ab <- y.ab[keep,]
design <- model.matrix(~factor(pool) + factor(tomato), y.ab$samples)
y.ab <- estimateDisp(y.ab, design, trend="none")
```


## Assuming most labels do not change

```{r}
y.ab2 <- calcNormFactors(y.ab)
y.ab2$samples$norm.factors
y.ab2 <- estimateDisp(y.ab2, design, trend="none")
fit.ab2 <- glmQLFit(y.ab2, design, robust=TRUE, abundance.trend=FALSE)
res2 <- glmQLFTest(fit.ab2, coef=ncol(design))
topTags(res2, n=10)
```

##  Testing against a log-fold change threshold

```{r}
res.lfc <- glmTreat(fit.ab, coef=ncol(design), lfc=1)
summary(decideTests(res.lfc))
topTags(res.lfc)
```


# Session Info

```{r, tidy=TRUE}
sessionInfo()
```

