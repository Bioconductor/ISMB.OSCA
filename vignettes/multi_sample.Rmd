---
title: Multi-sample analyses
vignette: >
  % \VignetteIndexEntry{Multi-sample analysis}
  %\VignetteEncoding{UTF-8}
  % \VignetteEngine{knitr::rmarkdown}
output:
  html_document:
    mathjax: null   
editor_options: 
  chunk_output_type: console
---

# Setup and data exploration

As said, we will use the the data from the Tal1 chimera experiment:

- Sample 5: E8.5 injected cells (tomato positive), pool 3
- Sample 6: E8.5 host cells (tomato negative), pool 3
- Sample 7: E8.5 injected cells (tomato positive), pool 4
- Sample 8: E8.5 host cells (tomato negative), pool 4
- Sample 9: E8.5 injected cells (tomato positive), pool 5
- Sample 10: E8.5 host cells (tomato negative), pool 5

Note that this is a paired design in which for each biological replicate (pool 3, 4, and 5), we have both host and injected cells.

We start by loading the data and doing a quick exploratory analysis, essentially applying the normalization and visualization techniques that we have seen in the previous lectures to all samples.

```{r setup, message = FALSE}
library(MouseGastrulationData)
sce <- WTChimeraData(samples=5:10, type = "processed")
sce
colData(sce)
```

We now normalize the data and visualize them in a tSNE plot.

```{r}
library(scater)
library(ggplot2)
library(scran)

# remove doublets
drop <- sce$celltype.mapped %in% c("stripped", "Doublet")
sce <- sce[,!drop]

# normalization
sce <- logNormCounts(sce)

# identify highly variable genes
dec <- modelGeneVar(sce, block=sce$sample)
chosen.hvgs <- dec$bio > 0

# dimensionality reduction
sce <- runPCA(sce, subset_row = chosen.hvgs, ntop = 1000)
sce <- runTSNE(sce, dimred = "PCA")

sce$sample <- as.factor(sce$sample)
plotTSNE(sce, colour_by = "sample")
plotTSNE(sce, colour_by = "celltype.mapped") +
    scale_color_discrete() +
    theme(legend.position = "bottom")
```

There are evident sample effects. Depending on the analysis that you want to do you may want to remove or retain the sample effect. For instance, if the goal is to identify cell types with a clustering method, one may want to remove the sample effects with "batch effect" correction methods.

For now, let's assume that we want to remove this effect.

# Correcting batch effects

```{r}

## This needs work
library(batchelor)
set.seed(10102)
merged <- correctExperiments(sce, 
    batch=sce$sample, 
    subset.row=chosen.hvgs,
    PARAM=FastMnnParam(
        merge.order=list(
            list(1,3,5), # WT (3 replicates)
            list(2,4,6)  # td-Tomato (3 replicates)
        )
    )
)

merged <- runTSNE(merged, dimred="corrected")
plotTSNE(merged, colour_by="batch")

# do we want to include the diagnostics about the batch correction?
```



# Differential Expression

Section 4 of OSCA multisample.

In order to perform a Differential Expression Analysis, we need to identify 
clusters of cells across samples/conditions (depending on the experimental 
design and the final aim of the experiment) to proceed with it

## clustering identification

```{r}
g <- buildSNNGraph(merged, use.dimred="corrected")
clusters <- igraph::cluster_louvain(g)
colLabels(merged) <- factor(clusters$membership)
merged <- runTSNE(merged, dimred="corrected", external_neighbors=TRUE)
merged <- runUMAP(merged, dimred="corrected", external_neighbors=TRUE)
```

```{r}
# table(colLabels(merged), merged$tomato)
gridExtra::grid.arrange(
    plotTSNE(merged, colour_by="tomato", text_by="label"),
    plotTSNE(merged, colour_by=data.frame(pool=factor(merged$pool))),
    ncol=2
)
```

As previously mentioned, to assign biological meaning to the found clusters, we
need to detect and assign gene-markers and provide cell labels.
For lack of time, we will skip this time and knowledge demanding process and we
use the annotation included with the dataset.
This annotation has been previously performed using a cell type atlas by 
Pijuan-Sala et al. (2019), using it as a reference for our dataset.
From the next figure we can see that there are quite a few similarities between
the clusters and the assigned labels, but in some cases we can notice that a
cluster can contain multiple cell types, highlighting the difficulty to identify
cell types by using cell markers and clusters.

```{r}
library(bluster)
pairwiseRand(colLabels(merged), merged$celltype.mapped, "index")
by.label <- table(colLabels(merged), merged$celltype.mapped)
pheatmap::pheatmap(log2(by.label+1), color=viridis::viridis(101))
```

## Pseudo-bulk samples

```{r}
# Using 'label' and 'sample' as our two factors; each column of the output
# corresponds to one unique combination of these two factors.
summed <- aggregateAcrossCells(merged, 
    id=colData(merged)[,c("celltype.mapped", "sample")])
summed

```

## Differential Expression Analysis

```{r}
label <- "Mesenchyme"
current <- summed[,label==summed$celltype.mapped]

# Creating up a DGEList object for use in edgeR:
library(edgeR)
y <- DGEList(counts(current), samples=colData(current))
y
```

Discard lowly "sequenced" samples

```{r}
discarded <- current$ncells < 10
y <- y[,!discarded]
summary(discarded)
```


Discard lowly expressed genes

```{r}
keep <- filterByExpr(y, group=current$tomato)
y <- y[keep,]
summary(keep)
```

Normalization factors by TMM

```{r}
y <- calcNormFactors(y)
y$samples
```

MD plot

```{r}
par(mfrow=c(2,3))
for (i in seq_len(ncol(y))) {
    plotMD(y, column=i)
}
```

MDS plot
    
```{r}
plotMDS(cpm(y, log=TRUE), 
    col=ifelse(y$samples$tomato, "red", "blue"))
```


```{r}
design <- model.matrix(~factor(pool) + factor(tomato), y$samples)
design
```

```{r}
y <- estimateDisp(y, design)
summary(y$trended.dispersion)
plotBCV(y)
```

```{r}
fit <- glmQLFit(y, design, robust=TRUE)
summary(fit$var.prior)
summary(fit$df.prior)
plotQLDisp(fit)
```

```{r}
res <- glmQLFTest(fit, coef=ncol(design))
summary(decideTests(res))
topTags(res)
```





# Differential Abundance

Section 6 of OSCA multisample.

```{r}

abundances <- table(merged$celltype.mapped, merged$sample) 
abundances <- as.data.frame(unclass(abundances))
head(abundances)
## add mosaic plot?
# df <- as.data.frame(abundances)
# Qui ho sommato le colonne REP1SHAM con REP2SHAM e le colonne REP1CAC con REP2CAC
# df <- cbind(rowSums(df[,c(1,3)]), rowSums(df[,c(2,4)]))
# colnames(df) <- c("CAC", "SHAM")
# rownames(df) <- c("Endothelial", "FAPs", "Immune Cells", "MuSC", "Myonuclei", "Nervous System", "Pericyte", "Smooth Muscular","Tenocyte" )
# Barplot
# Create a df for barplot
# cell.type <- rep(rownames(df), 6)
# condition <- c(rep(paste0("S", 6:10), each=dim(df)[1]))
# value <- c(df[,1], df[,2],df[,3], df[,4], df[,5], df[,6])
# 
# dfpl <- data.frame(cell.type,condition,value)
# library(RColorBrewer)
# newpal <- c(brewer.pal(12, "Set3"), brewer.pal(8, "Accent"), brewer.pal(8, "Dark2"), brewer.pal(8, "Set2"))
# #Stacked
# ggplot(dfpl, aes(y=value, x=condition, fill=cell.type,color=cell.type)) + 
#     geom_bar(position="fill", stat="identity")+ scale_y_continuous(labels = scales::percent) +
#   theme_classic()  +theme(legend.position="none")+ scale_color_manual(values=newpal)+
#   scale_fill_manual(values=newpal) #+ labs(y="Nuclei proportion(%)", x="", fill=NULL, color=NULL)   
#   # +theme_classic()  #+theme(legend.position="none")
```

```{r}
library(edgeR)
# Attaching some column metadata.
extra.info <- colData(merged)[match(colnames(abundances), merged$sample),]
y.ab <- DGEList(abundances, samples=extra.info)
y.ab
```

Filtering low abundance labels

```{r}
keep <- filterByExpr(y.ab, group=y.ab$samples$tomato)
y.ab <- y.ab[keep,]
summary(keep)
```

```{r}
design <- model.matrix(~factor(pool) + factor(tomato), y.ab$samples)
```


```{r}
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)
```

```{r}
fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
summary(fit.ab$df.prior)
plotQLDisp(fit.ab, cex=1)
```


```{r}
res <- glmQLFTest(fit.ab, coef=ncol(design))
summary(decideTests(res))
topTags(res)
```


## Assuming most labels do not change

```{r}
y.ab2 <- calcNormFactors(y.ab)
y.ab2$samples$norm.factors
y.ab2 <- estimateDisp(y.ab2, design, trend="none")
fit.ab2 <- glmQLFit(y.ab2, design, robust=TRUE, abundance.trend=FALSE)
res2 <- glmQLFTest(fit.ab2, coef=ncol(design))
topTags(res2, n=10)
```

    

# Session Info

```{r, tidy=TRUE}
sessionInfo()
```

